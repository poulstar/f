تو این پروژه قراره با Database و SharedPreferences کار کنیم.
از دیتابیس Hive استفاده میکنیم. NoSql هست و به صورت دیکشنری اطلاعات رو ذخیره میکنه. توی فلاتر خیلی معروفه و کراس پلتفرم هم هست.
اول ظاهر برنامه و صفحه اولیه رو تا جای مناسبی میسازیم. بعد از اون:
برای نصبش دقت میکنیم که یه دپندنسی hive هست که کلا برای دارت هست و یکی هم hive_flutter که برای کار کردن راحت تر با فلاتر به کار میره و ما hive_flutter رو
نصب میکنیم. اگه بخوایم کلا با زبان دارت یه برنامه بنویسیم که از hive استفاده میکنه، از اولی استفاده میشه. اینجا هم میشه از اولی استفاده کرد. ولی دومی
مخصوص فلاتر هست. hive_flutter رو اضافه میکنیم.

  hive_generator: ^1.1.1
  build_runner: ^2.1.7
این دو مورد رو هم تو قسمت dev_dependencies اضافه میکنیم که بعدا مجبور نشیم خودمون دستی generator بنویسیم. به جاش یه خط کد میزنیم خودش برامون اضافه میکنه.
اما موقع release کردن ازش استفاده ای نمیشه. به خاطر همین توی dev_dependencies مینویسیمش که ازش استفاده کنیم ولی حجم برنامه رو الکی بالا نبره.
این دو تا رو از تو گیت هاب خود همین hive_flutter آورد که نوشته بود.

برای شروع اول این که کتابخونه شو ایمپورت میکنیم و بعد هم اول تابع main، قبل از تابع run، با کلید await هایو رو راه اندازی میکنیم. initialize یعنی خط 
  await Hive.initFlutter();
رو به اول تابع main اضافه میکنیم.
hive از مفهوم باکس برای ذخیره اطلاعات استفاده میکنه. اطلاعات رو شبیه دیکشنری ذخیره میکنه. اما خب نمیدونه که ما چی میخوایم ذخیره کنیم و خودمون باید براش
تعیین کنیم. برای خرج هامون، یه کلاس تعریف میکنیم و ویژگی هایی که میخوایم هر "خرجی" داشته باشه رو تعیین میکنیم.
برای این که هایو بدونه ما چی رو میخوایم ذخیره کنیم، باید بهش بگیم. به همین منظور، کلاس خرجمون که داریم مینویسیم اکستند میکنه کلاس HiveObject رو. و در خط قبل
از تعریف کلاس، از نمادگذاری @HiveType(typeId: 0) استفاده میکنیم. در واقع بهش میگیم که یه نوع هایو تایپ داریم درست میکنیم با تایپ آی دی شماره صفر که به شرح
کلاس زیر هست. و از اینجا به بعد این کلاس رو میشه به راحتی با یک نام توی دیتابیس ذخیره کرد. اگه کلاس دیگه ای هم تعریف میکنیم تایپ ای دی اون رو میذاریم ۱ و ...
نوع int و ... رو خودش میشناسه. اما کلاس ما رو که نمیشناسه. به خاطر همین اضافه اش میکنیم. خب حالا داخل خود کلاسمون، هر کودوم از متغیرهایی که تعریف میکنیم رو
باید با نمادگذاری @HiveField(0) مشخص کنیم تا بتونیم بهشون دسترسی داشته باشیم. اولی میشه صفر. بعدی یک و ...
(یه جورایی انگار یه تیبل تعریف داریم میکنیم که اون فیلد ها رو داره. البته شبیشه و نه دقیقا اون. چون وسطه برنامه میشه ۵ تا باکس از یک نوع HiveType ساخت با
اسم های مختلف. خلاصه)
برای وفق دادن اطلاعاتمون با دیتابیس، آداپتر هم باید نوشته بشه. البته لازم نیست چیزی ما بنویسیم. خودش generator داره. کافیه که ما دستور
flutter packages pub run build_runner build رو اجرا کنیم.
یه فایل برامون میخواد بسازه. اما کجا؟ هیچ جا. ارور واضح قرمز رنگی نمیده. چون کد رو تولید کرده و میگه successfull بوده. اما اگه برگردیم عقب و نگاه کنیم میگه
که باید عبارت part data.g.dart رو اضافه کنیم. در واقع برای این که generate کنه برامون، باید کلمه کلیدی part رو بنویسیم و داخل کوتیشن، اسم فایل دارتمون رو
هم بنویسیم. منتهی یه .g هم قبل از دارت بذاریم. در این صورت اول کار IDE بهمون ارور میده چون همچین فایلی وجود نداره. اما با زدن همون دستور
flutter packages pub run build_runner build
آداپتری رو که نوشته کدهاش رو داخل اون فایل میریزه و ما دیگه لازم نیست بنویسیم کد ها رو. اگر هم بعدا تغییری دادیم دستی اون فایل رو عوض نکنیم دوباره به
generator دستور رو بدیم که برامون درستش کنه.

(یادآوری واسه خودم: یه جای پروژه لازم شد که یک جای کلاسم رو تغییر بدم و دوباره کدها رو generate کنم. اما خودم دستی عوض کردم و ارورهای تغییر نام رو که داده بود
اضافه کردم چک نکردم که کار میکنه یا نه و گفتم با همون دستور درستش کنم که بهم ارور داد. برای رفع ارور به دستور flutter clean رسیدم. به طور خلاصه بعضی از 
اوقات به مشکلی بر خوردم تو این پروژه های اخیر که gradle نمیتونست build کنه. و stop کردن و اجرای مجدد هم مشکل رو حل نمیکرد. یک بار دیگه اش موقع اضافه کردن
sharedpreferences به برنامه بود. خلاصه بگم توی اکثر حالت هایی که به مشکل انتظار برای این که gradle build کارش رو انجام بده برمیخوردم دستور flutter clean 
در ترمینال باعث میشه که یه بار کش رو پاک کنه و یک سری از فایل ها رو. حتی بعد از اجراش به خود ویجت های فلاتر هم ارور میداد که نمیشناستشون. اما وقتی دوباره 
build میکردم درست میشد و برنامه هم کار میکرد. توی یک مورد که خود همین sharedpreferences بود، build کردن باز هم خیلی طول کشید. کنسلش کردم. و با اینترنت دیتا 
که تست کردم در کمتر از دقیقه تونست build بکنه و کار کرد. نکته مهم این که با اولین build ای که اولین بار میکنیم و یه ربع طول میکشه فرق داره. چون کلش رو پاک 
نمیکنه و فقط cache رو پاک میکنه. (در ضمن در کل این پروژه با همه اینترنت ها به شکن هم وصل بودم.) آخرین نکته این که لزومی نداره که حتما با دستور flutter clean 
همه مشکلات حل بشه. هنوز مثلا مشکل حداقل و حداکثر ورژن خود فلاتر حل نشده و تو این پروژه خیلی از stackoverflow و chatgpt و سایت خود فلاتر و یک مورد هم از 
کامنت های github که گذاشته بودن کمک گرفتم و حتما جلوی بچه ها هم به ارور خوردم این کار رو بکنم. فقط نوشتم که سریعتر بتونم به نتیجه برسم و یه یادآوری باشه برام.)

در ادامه، میریم به کد اصلی و داخل تابع main بعد از init کردن Hive، بهش میگیم که از چه آداپتری استفاده کنه. با دستور 
  Hive.registerAdapter(KharjAdapter());
  بهش میگیم که از آداپتری که برامون تولید کرده استفاده کنه برای هماهنگ سازی ذخیره و بازیابی داده ها.
  با دستور
      await Hive.openBox<Kharj>('kharjs');
بهش میگیم که یه باکس باز کنه به اسم 'kharjs' و با همین نام میتونیم در ادامه برنامه بهش دسترسی داشته باشیم.
خب حالا داخل build، اولین کاری که میکنیم اینه که همین باکس رو باز کنیم و داخل یه متغیر ذخیره اش میکنیم. final box = Hive.box<Kharj>('kharjs');
برای اضافه کردن یه آیتم جدید به باکس، از تابع add استفاده میشه. اگر از قبل وجود داشته باشه و بخوایم آپدیت کنیم چیزی که از قبل وجود داشت رو از تابع
save استفاده میکنیم. به خاطر همین تو برنامه یه if و else نوشتیم که اگه وجود نداشت بسازه با متد add و اگه وجود داشت آپدیتش کنه.

(البته نسخه اولیه پروژه بود و تو نسخه ای که رو گیت هاب گذاشتم، کل ایجاد خرج به یک ویجت تبدیل شده و ویرایش خرج به یه ویجت دیگه. برای ایجاد 
خرج باید یک خرج جدید درست کنیم و add کنیم و برای ویرایش یک خرج، باید از خرجی که وسط برنامه از توی باکس درش آوردیم استفاده کنیم و تابع save رو استفاده کنیم.)

با این حال آپدیت انجام نمیشه و باید یه بار هات ریلود رو بزنیم یا برنامه رو دوباره باز کنیم. برای قشنگ شدن همین مرحله هم از ویجتی به اسم ValueListenableBuilder
استفاده میکنیم که ۲ تا از اتریبیوت هاش اجباریه. یکیش builder که یک تابع باید بهش بدیم که بهمون ویجت برمیگردونه. یکیش هم valueListenable این که منتظر چی
هست که تغییر کنه. ما بهش میگیم که منتظر تغییر باکس باشه. ValueListenableBuilder<Box<Kharj>>. باکسی که توش خرج ذخیره شده. دقت کنم که اتریبیوت builder به 
عنوان ورودی تابعی میگیره که ویجت برمیگردونه. پس ListView.builder ای که نوشته بودیم رو فقط اینجا نمیذاریم، بلکه return پشتش رو هم باید بذاریم.

ویجت های جدیدی که استفاده کردم رو اینجا دیگه توضیح نمیدم. برای گرادیانت رنگ. برای PageView. برای تغییر رنگ پس زمینه ElevatedButton ها و ... این موارد رو
دیگه اینجا ننوشتم و هر کودوم رو سر کلاس به عنوان تمرین چند دقیقه ای به بچه ها بدم که انجام بدن و خودشون پیدا کنن راه حل رو. بعد با هم درست کنیم. این جوری
خودشون هم بهتر یاد میگیرن.