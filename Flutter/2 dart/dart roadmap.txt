شروع کار با دارت.
معرفی سایت dartpad.dev که در تاریخ ۲۸ فروردین ۱۴۰۲ که دارم این رو مینویسم سایتش باز میشه. اما وقتی ران رو میزنیم ارور میده.
با آی پی شکن یا آی پی مشابه مشکل حل نشد. ولی با استفاده از فیلتر شکن حل شد. در ضمن برای دوره اندروید استفاده از یک فیلتر شکن خوب حتما توصیه میشه.
وگرنه مشکلات خیلی زیاد میشه به طوری که کلا از برنامه نویسی اندروید متنفر میشید. میشه به زور و با سماجت زیاد و شکن و این جور چیز ها کار رو پیش برد.
اما واقعا ۱۰ برابر زمان میبره.

برم سراغ زبان دارت.
۱- معرفی تابع main که تابع اصلی است و دروازه اجرای برنامه هامون. و نوشتن برنامه Hello World. توضیحات }{، نحوه نوشتن تابع. استفاده اجباری
از سمی کالن و تابع پرینت.

۲- معرفی انواع داده که خودم تو کلاس تا جای ممکن از var استفاده نمیکنم که وقتی کد رو میبینم بدونم چی به چیه. اما var هم بگم.
int اعداد صحیح. double اعداد اعشاری. num کل اعداد. (اینت و دابل هر دو زیرمجموعه کلاس نام هستند. همون طوری که نام زیرمجموعه کلاس var هست.)
String با S بزرگ برای کار با رشته ها. bool و true و false که حرف اولشون برخلاف پایتون کوچیک هست. List و Map که توی کدها انواع مختلفشون رو توضیح بدم.

۳- انواع دیگه رو هم بگم که میشه استفاده کرد و همه شون نوعی var هستند و خود var از کلاس Object ارث برده. خلاصه این که همشون از کلاس Object ارث بردن
و ویژگی ای به اسم runtimeType رو که دارن میتونیم ببینیم چی هست نوع اون آبجکت.

۴- متغیرهای لوکال و گلوبال رو بگم. متغیر گلوبال بیرون از تابع تعریف میشه و همه جا قابل دسترسی. اما لوکال فقط تو محدوده خودش.

۵- مدیفایر late رو بگم. به خاطر ویژگی نال سیفتی که زبان دارت داره، بهمون اجازه نمیده که متغیر تعریف کنیم بدون مقدار دهی اولیه.
مثلا String گلوبال تعریف کردم بدون مقدار اولیه ارور میده. اما داخل تابع بهم ارور نداد و موقعی که ازش استفاده کردم ارور داد.
برای ندادن ارور میشه از کیوورد late استفاده کرد و بعدا بهش مقدار داد. البته اون لحظه ارور رو رفع میکنه. اما اگه بعدا بهش مقدار ندیم ممکنه که 
runtime error بگیریم. پس حواسمون باشه که اگه late گذاشتیم خودمون درست هندلش کنیم. در ضمن نال زبان دارت هم به صورت null با حروف کوچیک نوشته میشه. یک عملگر
? هم داریم که میتونیم موقع تعریف یک متغیر بگیم که میتونه این متغیر نال هم باشه و توی کدها ازش استفاده کردیم. اگه اونی که late هست رو درست هندل نکنیم
ران تایم ارور میده. اما اونی که ؟ میذاریم گفتیم میتونه نال باشه. پس ارور نمیده و اگه مقدار ندیم توش نال ذخیره میشه.

۶- مدیفایر های final و const رو دقیق بگم به بچه ها که چیه. const کلا یه چیز ثابت هست و فقط برای این که هزار جای برنامه رو هر بار اسم متغیر رو عوض
نکنیم ازش استفاده میکنیم. مثلا ۴۰ جا از متغیر color1 استفاده میکنیم که 'blue' هست. حالا اگه بخوایم بذاریم 'light blue' لازم نیست ۴۰ جا رو تغییر بدیم. متغیر
const مربوط به اون رو تغییر میدیم. در واقع قبل از کامپایل متغیر const مقدار دهی میشه و قابل تغییر نیست. final هم همین طوره با این فرق که زمان runtime هم
مقدار میگیره. یعنی جفتشون فقط یه بار میشه بهشون مقدار داد و بعد از اون قابل تغییر نیستند. final زمان runtime میگیره (قبل از کامپایل هم میشه ولی خب بیخوده
و به جاش const میذاریم.) const فقط قبل از کامپایل مقدار میگیره. late قبل از final کار میکنه. ولی قبل از const نه.
یادداشت برای خودم: instance variables میتونن فاینال باشن. چون برای هر نمونه از کلاس میتونه متفاوت باشه و در زمان اجرا تعیین شه. ولی const نمیتونن
باشن که به کلاس ها برسیم به جای static رو معرفی میکنیم اونجا.

۷ و ۸ و ۹ و ۱۰- عملگرها در دارت:
عملگرهای حسابی:
+ جمع		- تفریق		* ضرب		/ تقسیم کامل		~/ خارج قسمت تقسیم		% باقیمانده تقسیم
عملگرهای افزایش و کاهش:
++ افزایش		-- کاهش		و همون قوانین اولویت رو داره اگه قبل یا بعدش بنویسیم.
عملگرهای تساوی و مقایسه ای:
== تساوی		!= مخالف بودن		< > <= >=	بزرگتر و کوچکتر و بزرگتر یا مساوی و کوچکتر یا مساوی بودن
عملگرهای چک کردن تایپ:
is برای این که بررسی کنیم متغیری از نوع خاصی از کلاس هست.
is! برای این که بررسی کنیم متغیری از نوع خاصی از کلاس نیست.

عملگر تایپ کست کردن:
as برای این که بگیم نوع متغیرمون رو از چه جنسی در نظر بگیره. تو کد هشتم نمونه آوردم. میشه قبلش نوع متغیر رو که تعیین میکنیم نوع درست رو بذاریم اگه
میخوایم تایپ کستش کنیم. اما به هر حال همچین اپراتوری رو داره. تو ایمپورت کتابخونه ها مثل پایتون کاربردش مناسب تر و بهتره و میشه
اسم مستعار براشون در نظر گرفت.

عمرگرهای انتساب:
=		+=		-=		*=		/=		%=		~/=

عملگرهای منطقی:
&&		||		!


۱۱- توابع رو بگم چه طور مینویسن تو دارت. کلیت خود تابع مهمه و arrow function هم مهمه.

۱۲(گفته نشه سر کلاس)- چیزی که شبیه *args هست تو پایتون رو نوشتم. اما خیلی مهم نیست و اگه گفته نشه بهتر هم هست. شاید گیج بشن. چون بعدی مهم تره.

۱۳- اگه بخوایم بتونیم با نام آرگومان ها رو بدیم، از آکولاد استفاده میشه. وقتی که آرگومان ها رو از نوع نامدار تعریف میکنیم حتما باید موقع استفاده گفته بشه
که کودوم ورودی رو داریم میگیم. و وقتی علامت آکولاد رو میذاریم، در واقع تبدیل میشن به **kwargs که خب کیوورد آرگومان ها هم اختیاری هستند.
حالا اگه بخوایم دوباره اجباری بشن باید پشتشون required رو بذاریم. و وقتی اجباری میشن، دیگه مقدار پیش فرض قبول نمیکنن. این دوتایی که گفتم دقیقا شبیه *args و
**kwargs تو پایتون نیستند. اما تا حدودی شبیه هستند. خلاصه اصلا روشون تمرکز نکنم و بچه ها هم لازم نیست کامل یاد بگیرن. هر چیزی که فقط برای فلاتر لازم هست رو
بگم که آکولاده مهم هست. اما اونی که لیست میدیم و کروشه هست مهم نیست.

۱۴- ساختار if و else.

۱۵(گفته نشه سر کلاس)- ساختار switch case.(ترجیحا گفته نشه.)(اگه بچه خفنی تو کلاس بود گفته بشه و سریع هم رد شم. چون خیلی مهم نیست. فقط بدونه که دارت داره این رو.)

۱۶- حلقه for. (این حلقه از نوع index ای هست و فقط با عدد کار میکنه.)

۱۷- حلقه while. (که با غیر عدد هم کار میکنه.)

۱۸- حلقه do while. (که سریع گفته بشه و رد بشم. خیلی مهم نیست. نگفتم هم نگفتم. فقط بدونن که تو دارت هست.)

۱۹- حلقه foreach.

۲۰- دستور break.

۲۱- دستور continue (که مهم نیست. ترجیحا گفته نشه.(اگه بچه خفنی تو کلاس بود گفته بشه و سریع هم رد شم. چون خیلی مهم نیست. فقط بدونه که دارت داره این رو.)

۲۲- شروع بحث کلاس. در مورد کانستراکتور، نکته ای که داره اینه که ریترن تایپ نداره و تو دارت باید حتما هم نام با خود کلاس باشه. کد اول مثل اکثر زبان های
برنامه نویسی هست. اما دارت روش ساده تر هم داره که تو کد بعدی میبینیم.

۲۳- خلاصه نویسی کانستراکتور هست که خیلی مفیده و حتما گفته بشه. قوانینش مثل نوشتن تابع هست چون واقعا هم تابع هست.

۲۴- نوع  named parameters هم میشه تعریف کرد. در این صورت موقع ساختن نمونه باید اسم رو بهش بگیم. اگه بخوایم ورودی هاش اجباری باشه مثل حالت قبلی ولی
پارامترها هم نامدار باشن از کلمه کلیدی required استفاده میکنیم.

۲۵(گفته نشه سر کلاس)- named constructor نوشتیم. جالب بود فقط برای خودم گفتم داشته باشم. دو تا named constructor توش نوشتیم.

۲۶(گفته نشه سر کلاس)- کانستراکتور اصلی رو برداشتم و فقط دو تا named constructor نوشتم که توی دومی هم بدنه اش رو بزرگ کردم و چند کار رو نوشتم که انجام بده.

۲۷(گفته نشه سر کلاس)- نشون دادیم که کانستراکتورها میتونن همدیگه رو هم صدا کنن. شبیه همون super توی پایتون. البته اینجا هم super رو داریم و برای
کال کردن کلاس پدر هست. اینجا چون داخل خود همین کلاس هست و ارث بری نکرده دیگه کلمه super نوشته نمیشه.

۲۸- اپراتور ترنری ?: هست که مهمه و حتما گفته بشه و مطمئن شم همه یاد گرفته باشن. واقعا توی فلاتر کار رو ساده میکنه و وسط اکسپرشن های تو در تو، واقعا
نوشتن ایف و الس عذاب آوره. اونجا حتما به کارمون میاد. و روی این خوب دقت کنم که همه یاد بگیرن.

۲۹- اپراتور ?? هست. این اپراتور، نال بودن یک متغیر رو بررسی میکنه. اگر نال باشه، عبارت بعد از ?? رو برمیگردونه. اگه نباشه، مقدار خود اون
عبارت رو. در واقع ?: میشه کامل داخلش شرط نوشت و هر چیزی رو بررسی کرد. اما ?? فقط برای بررسی این هست که اون متغیرمون null هست یا نه. لازم نیست این یکی رو
خیلی توضیح بدم. کاربردش کمتر هست. اما گفته بشه بد نیست. یه توضیح مجددی هم راجع به ? بعد از اسم متغیر بدم. ! بمونه برای بعد.


از کد سی ام دوباره بحث کلاس ها هست. ارث بری و غیره.
۳۰- کلاس اسپرت کار از کلاس کار ارث بری کرده و پارامترهایی که تو کلاس پدر اجباری هست اینجا هم اجباریه. اما میتونیم خودمون بهشون مقدار بدیم. مثل همین
مثالی که نوشتیم.

۳۱- از مفهوم ارث بری استفاده کردیم و این بار تابع honk رو اوراید کردیم که کار دیگه ای انجام بده.

۳۲- حالا اگه نخواد کامل عوض کنه و یک سری از کارها رو میخواد مثل پدرش انجام بده و بعد یک سری کارهای اضافه انجام بده میشه super رو صدا کرد.

۳۳(گفته نشه سر کلاس. اگه خوب بودن میشه گفت)- توضیح کلاس ابسترکت با مثال Animal خیلی خوب مشخص شده. اما تو فلاتر به کار بچه ها نمیاد. از خود کلاس abstract نمیشه
نمونه ساخت. اما میتونه ارث برندگانش رو مجبور کنه که یک سری تابع رو پیاده سازی کنند. در عین حال میتونه یک سری از چیزها رو هم داخل خودش پیاده سازی کنه.

۳۴(گفته نشه سر کلاس. حتی اگه خوب بودند هم لازم نیست.)- یه مفهومی هست به اسم interface که تو دارت با استفاده از کلمه کلیدی implements (به جای extends)
نوشته میشه. interface شبیه کلاس ابسترکت هست. با این تفاوت که وقتی کلاسی ازش ارث بری میکنه، حتما باید همه چیزش رو override کنه. اگه یکی رو هم نکنه
ارور میده و همه چیز باید داخل کلاس فرزند نوشته بشه.
سوال: توی ابسترکت کلاس که دستمون بازتره. چرا از interface استفاده کنیم؟ به خاطر این که تو دارت فقط میشه یک کلاس رو اکستند کرد. اما میشه با ویرگول بگیم که
یک کلاسی چند تا interface رو implement میکنه. توی ابسترکت کلاس میشه private تعریف کرد. اما تو interface نمیشه. تفاوت هاشون. میگم اصلا به بچه ها نگم. حتی اگه
قوی بودند. فقط خودم بدونم که اگه کسی پرسید بتونم بگم. اما توضیح اضافه ندم اصلا.

۳۵(گفته نشه سر کلاس. اگه خوب بودن میشه گفت)- مفهوم encapsulation یعنی این که داده ها رو بسته بندی کنیم. کاری که حالت عادی تو کلاس میکنیم همین هست.
اما مفهوم دقیقش اینه که فیلدهاش رو private کنیم که کسی از بیرون بهش دسترسی نداشته باشه مستقیما و از گتر و ستر استفاده کنه. تو این کد نمونه جاوایی اش هست.

۳۶(گفته نشه سر کلاس.)- اما تو زبان دارت به صورت ضمنی خودش وقتی assign میکنیم چیزی رو یا میخوایم بخونیم از setter و getter استفاده میکنه.
با این حال باز هم دو تا keywoard داره به نام های set و get که میشه مثل کد بعدی، خودمون برای کلاسمون setter و getter بنویسیم.

۳۷ و ۳۸(گفته نشه سر کلاس. اگه خوب بودن و علاقه داشتن میشه. اما لزومی نداره گفته بشه و تو فلاتر خیلی به کار نمیاد.)- با استفاده از مفهوم میکسین
تونستیم یه کاری رو که توی چند تا کلاس مختلف انجام میشد و ربطی به هم نداشتن، مشترک کنیم و حجم کد رو کم کنیم. در واقع تو میکسین یه متغیر با تابع آماده نوشتیم.
حالا هر کلاسی که میخواد داخل خودش اون متغیر رو تعریف کنه و به همون صورت از تابع مربوط بهش استفاده کنه لازم نیست پیاده سازیش کنه و میتونه با استفاده
از کیوورد with ازش استفاده کنه. میکسین ها رو هم میشه با ویرگول بیشتر از یکی بهش داد. شبیه همون میکسین جنگو هست. آخر سر هم گفت که با کیوورد on میشه
محدود هم کرد که چه کلاس هایی بتونن از یک میکسین استفاده کنند که دیگه خیلی بی خود بود به نظرم ننوشتم.

۳۹- کامنت ها به طور کامل توضیح داده شده. ۲ تای اول رو که حتما تا این جا گفتیم. داک استرینگ رو فقط یه توضیح کوتاه بدیم که برای کارهای جدی
استفاده میشه و حتما باید بنویسنش برنامه نویس های حرفه ای. وگرنه کسی نمیتونه از کلاس ها یا توابعشون استفاده کنه.

۴۰- اول تابع foreach رو گفتم. (حلقه foreach) قبلا گفته شده. این یکی تابع هست که داخل خودش یه تابع میگیره. مثل پرینت که تو کد چهلم هست. و برای هر کودوم از
اعضای لیست تابع داخلش رو که نوشتیم صدا میکنه با اون ورودی.

۴۱- حالا میتونیم اون تابع رو خودمون بنویسیم.

۴۲- با استفاده از arrow function اون رو ساده تر کردیم. اما arrow function باز هم اسم داره و فقط آکولاد رو حذف کرده.

۴۳- باز هم ساده ترش کردیم و همون جا صداش کردیم و اصلا تابعی که اسم جداگانه داشته باشه تعریف نکردیم. به این نوع تابع میگن ananymous function که اسم نداره
(بعضی جاها lambda function هم میگن). حالا که ananymous function رو هم یاد گرفتیم، میتونیم داخلش به جای arrow function از یه تابع کامل استفاده کنیم و کدمون
رو اونجا بنویسیم. در واقع این همه کدهای مختلف رو گفتیم که بگیم توی دارت اگه لازمه برای ورودی تابعی، یک تابع بفرستیم، میشه همونجا تابعش رو بدون اسم تعریف کرد.
حالا جدا از این که میتونه arrow function باشه، میتونه تابع با بدنه کامل هم باشه و فقط اسم نداشته باشه و اتفاقا تو فلاتر هم ازش خیلی استفاده خواهیم کرد.

۴۴- نمونه ای از تابع بدون نام (ananymous function) که داخل تابع foreach نوشتیمش. foreach یه نمونه تابع هست که به عنوان ورودی تابع میگیره.
تو فلاتر از این تابع ها زیاد استفاده میکنیم.

۴۵ (گفته نشه سر کلاس)- موضوع بعدی اکستنشن متد هست که میتونیم یه کلاس از پیش تعیین شده رو خودمون بهترش کنیم و یه سری متد بهش اضافه کنیم. بدون این که
کلاس جدیدی تعریف کنیم و ازش ارث بری کنه. مثلا برای این که بتونیم استرینگ رو به عدد تبدیل کنیم، لازم نیست کلاس جدا تعریف کنیم که از String
ارث بری کنه (البته این کار رو کلا به ما اجازه نمیده زبان دارت.) و اون کلاس رو بهترش کنیم. اما میتونیم روی کلاس String اصلی متدهایی که دوست داریم رو
اضافه کنیم. روی کلاس های خودمون هم میشه اکستنشن متد اضافه کرد. اما دیگه انجام ندادم.
جنریک هم جالب بود. اما کلا ننوشتم چیزی و به بچه ها هم نگیم. همون Template توی C++ بود.

۴۶- مفهوم مُدیفایر static رو میبینیم اینجا. داخل کلاس ها، نمیتونیم متغیری از نوع const داشته باشیم. در واقع متغیر های داخل کلاس برای هر نمونه هستند و
اگه بخوایم متغیری برای کل کلاس تعریف کنیم، باید const تعریف کنیم. static ها متغیرهای خود کلاس هستند و نه نمونه های اون کلاس و برای دسترسی بهشون اسم کلاس رو
مینویسیم و نقطه میذاریم و قابل دسترسی میشن. (نه اسم نمونه و بعدش نقطه) حالا وقتی یه متغیر static تعریف کردیم که مال خود کلاس هست، اون رو میشه const یا
final در نظر گرفت. اما اجباری نیست و میشه int خالی هم در نظر گرفت و بشه تغییرش داد وسط کار.

۴۷- کمی کار کردن با توابع List ها و Map ها که لازم نیست همه رو کامل یاد بگیرن. فقط بگم که زبان دارت پیشرفته هست و مثل پایتون لیست و دیکشنری (همون مپ)
و مجموعه (set) داره. و کلی متد آماده براشون نوشتن و فقط با چند تاشون کار کنیم که آشنا بشن. مثل first یا last تو لیست ها. خیلی ساده و در حد ابتدایی.
یک تمرین ساده هم به بچه ها بدم که برای تمرین انجام بدن و کمی خودشون با سینتکس دارت آشنا بشن.
